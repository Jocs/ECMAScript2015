<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Class 基本用法</title>
	<script src='../node_modules/babel-core/browser.js'></script>
</head>
<body>
	<h3>Class类的用法（javascript对象的原型继承关系）</h3>
	<script type='text/babel'>
		class Parent{
			constructor(name,age){
				this.name = name;
				this.age = age;
			}
			showName(){
				console.log(this.name);
			}
		}
		class Child extends Parent{
			constructor(name, age, work){
				super(name, age);
				this.work = work;
			}
		}
		let parent = new Parent('ran', 49);
		let child = new Child('ran', 29, 'scientist');
		//name 属性是继承的
		console.log(child instanceof Child);
		console.log(child.constructor === Child);
		console.log(child.hasOwnProperty('name'));//true
		console.log(child.hasOwnProperty('work'));//true
		console.log(child.hasOwnProperty('showName'));//false
		//在ECMAScript2015 中方法都是定义在原型上的
		console.log(parent.hasOwnProperty('showName'));//false
		console.log(parent.__proto__.hasOwnProperty('showName'));//true
		console.log(Object.getPrototypeOf(parent).hasOwnProperty('showName'));
		console.log('***************************');
		/*
		* 以下是原型继承的关系 下面都是全等关系 all true
		*/
		console.log(child.__proto__ === Child.prototype);
		console.log(parent.__proto__ === Parent.prototype);
		console.log(parent.__proto__ === Child.prototype.__proto__);
		console.log(Child.__proto__ === Parent);
		console.log(Child.prototype.__proto__ === Parent.prototype);
		console.log(Parent.__proto__ === Function.prototype);
		console.log(Function.prototype.constructor === Function);
		console.log(Object.prototype.constructor === Object);
		console.log(Function.prototype.__proto__ === Object.prototype);
		console.log(Function.__proto__ === Function.prototype);
		console.log(Object.__proto__ === Function.prototype);
		console.log(Object.prototype.__proto__ === null);
	</script>
</body>
</html>